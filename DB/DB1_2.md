# Contents Of DB1(2)
- [자바 예외의 이해](#자바-예외의-이해)
  - [함부로 Exception으로 처리하거나 던지면 안되는 이유](#함부로-exception으로-처리하거나-던지면-안되는-이유) 
  - [자바 예외 계층](#자바-예외-계층)
  - [체크 예외와 언체크 예외](#체크-예외와-언체크-예외)






###### Reference
- **(main)** 인프런 김영한 스프링 DB 1편 : https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-db-1/dashboard





# 자바 예외의 이해

## 자바 예외 계층

<img width="805" alt="DB1" src="https://github.com/whxogus215/Backend-Study-Archive/assets/70999462/bf6b1fc2-1902-42d4-8f8c-8f32e05a6e6a">

<img width="806" alt="DB 2" src="https://github.com/whxogus215/Backend-Study-Archive/assets/70999462/af083146-d28e-40be-895f-b45f6a120468">

- 체크 예외 : 컴파일러가 **체크하는 예외이다.** 따라서 체크 예외를 처리하지 않으면 컴파일 에러가 발생한다.
    - 여기서 처리란 `try-catch` 혹은 `throws`를 뜻한다.
- 언체크 예외 : 컴파일러가 **체크하지 않는 예외이다.** 따라서 예외를 처리하지 않아도 컴파일이 된다.

<img width="815" alt="DB3" src="https://github.com/whxogus215/Backend-Study-Archive/assets/70999462/600bf600-9b5e-4ae4-97fd-69be4b673e6e">

예외는 처리하거나 던지거나 둘 중 하나를 반드시 해야 한다. 예외를 잡거나 던질 경우, 해당 예외의 자식 예외들도 다같이 처리된다.
- `Exception`을 `catch`로 잡을 경우, `Exception`을 포함한 하위 예외들도 잡을 수 있게 된다.
- `Exception`을 `throws`로 던질 경우, `Exception`을 포함한 하위 예외들도 던질 수 있게 된다.

### 함부로 Exception으로 처리하거나 던지면 안되는 이유
따라서 `Exception`으로 한번에 던지거나 잡을 수가 있기 때문에 이를 사용하면 간편할 수는 있다. 하지만 이는 지저분하고 좋지 않은 코드이다.
왜냐하면 **최상위 예외로 처리할 경우, 처리되지 않아야 할 예외들도 싸잡아서 다 처리되기 때문이다.** throws도 마찬가지이다. `throws Exception`으로 해버리면
이 또한 하위 예외들도 전부 던지게 되는 것이므로 좋지 않은 코드이다. 

**예외를 처리하지 못하고 계속 던질 경우, 최종적으로 `main()`의 쓰레드에서 예외 로그를 출력하며 시스템이 종료된다.**
그러나 웹 어플리케이션의 경우, 여러 사용자의 요청을 처리하기 때문에 하나의 예외로 인해 시스템이 종료되어선 안된다.
따라서 던져진 예외를 **WAS가 잡아 처리하고, 사용자로 하여금 개발자가 만든 에러 페이지를 보여주도록 한다.**

## 체크 예외와 언체크 예외
### 체크 예외
```java
/**
     * Exception을 상속받은 예외는 체크 예외가 된다.
     */
    static class MyCheckedException extends Exception {
        public MyCheckedException(String message) {
            super(message); // 이미 구현된 생성자를 호출
        }
    }
```
이처럼 `Exception`을 상속받는 예외 클래스는 **체크 예외가 된다.** 이처럼 생성자로 에러 메세지를 받을 수도 있다.

```java
/**
     * Checked 예외는
     * 예외를 잡아서 처리하거나, 던지거나 둘 중 하나를 필수로 선택해야 한다.
     */
    static class Service {

        Repository repository = new Repository();

        /**
         * 예외를 잡아서 처리하는 코드
         */
        public void callCatch() {
            try {
                repository.call();
            } catch (MyCheckedException e) {
                // 예외 처리 로직
                log.info("예외 처리, message={}", e.getMessage(), e); // log.info 마지막에 예외 참조변수를 넣으면 stackTrace를 출력해준다.
            }
        }

        /**
         * 체크 예외를 밖으로 던지는 코드
         * 체크 예외는 예외를 잡지 않고 밖으로 던지려면 throws 예외를 메서드에 필수로 선언해야 한다.
         * @throws MyCheckedException
         */
        public void callThrow() throws MyCheckedException {
            repository.call();
        }
    }

    static class Repository {
        public void call() throws MyCheckedException {
            throw new MyCheckedException("ex");
        }
    }
}
```
- `log.info()`에서 마지막에 참조변수 e를 넣어주면 stackTrace를 출력해준다.
- 이처럼 체크 예외의 경우, 잡거나 던지거나하는 예외 처리를 반드시 해줘야 한다.
  - 예외 처리를 하지 않을 경우, `Unhandled exception`가 발생한다.

### 체크 예외의 장단점
- 장점 : 컴파일러가 예외를 체크하기 때문에 개발자가 실수할 일이 적어진다.
- 단점 : 개발자가 신경쓰고 싶지 않은 예외들까지 전부 처리를 해야 한다. 또한 의존관계 문제가 생긴다.(뒤에서 설명)

### 언체크 예외
```java
/**
     * RuntimeException을 상속받은 예외는 언체크 예외가 된다.
     */
    static class MyUncheckedException extends RuntimeException {
        public MyUncheckedException(String message) {
            super(message);
        }
    }
```
이처럼 `RuntimeException` 예외를 상속받는 예외 클래스는 전부 **언체크 예외가 된다.** 마찬가지로 생성자를 통해 에러 메시지를 받을 수 있다.

```java
/**
     * Unchecked 예외는
     * 예외를 잡거나, 던지지 않아도 된다.
     * 예외를 잡지 않으면 자동으로 밖으로 던진다.
     */
    static class Service {
        Repository repositoy = new Repository();

        /**
         * 필요한 경우 예외를 잡아서 처리하면 된다.
         */
        public void callCatch() {
            try {
                repositoy.call();
            } catch (MyUncheckedException e) {
                // 예외 처리 로직
                log.info("예외 처리, message={}", e.getMessage(), e);
            }
        }

        /**
         * 예외를 잡지 않아도 된다. 자연스럽게 상위로 넘어간다.
         * 체크 예외와 다르게 throws 예외 선언을 하지 않아도 된다.
         */
        public void callThrow() {
            repositoy.call();
        }
    }


    static class Repository {
        public void call() { // 언체크 에외이기 때문에 throws 선언 생략 가능(해도 상관은 없다.)
            throw new MyUncheckedException("ex");
        }
    }
```
언체크 예외는 `throws`를 통해 예외를 던지지 않아도 에러가 발생하지 않는다. 정확히는 **생략이 가능한 것이다.** `throws`를 생략해도
자동으로 던지게 된다. 

```java
@Test
void unchecked_throw() {
    Service service = new Service();
    Assertions.assertThatThrownBy(() -> service.callThrow())
            .isInstanceOf(MyUncheckedException.class);
}
```
다만 예외를 최종적으로 처리할 경우에는 이처럼 `assertThatThrownBy()`를 통해 예외 클래스를 확인해야 한다.

### 언체크 예외의 장단점
- 장점 : 신경쓰고 싶지 않은 언체크 예외를 무시할 수 있다. 언체크는 `throws`를 생략할 수 있기 때문이다. 이는 의존관계로 참조하지 않아도 되는 장점이 된다.
- 단점 : 개발자의 실수로 인해 예외가 누락될 수 있다. 언제 어느 부분에서 예외가 발생했는지 체크하기가 어렵기 때문이다. 반면에 체크 예외는 컴파일 단계에서
바로바로 확인이 가능하다.

