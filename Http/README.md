# Contents Of Http
- [IP 프로토콜 그리고 TCP/UDP](#IP-프로토콜-그리고-TCP/UDP)
- [PORT 그리고 DNS](#PORT)
- [URL 과 URI](#url과-uri)
- [HTTP 특징](#http)
  - [Stateless](#stateless)
  - [비 연결성](#비-연걸성)
  - [HTTP 메시지 구조](#http-메시지-구조)
- [HTTP API 설계](#http-api-설계)
- [HTTP 메서드](#HTTP)
  - [HTTP 속성](#HTTP-메서드의-속성)
  - [HTTP API 설계 예시](#HTTP-API-설계-예시)
- [HTTP 상태코드](#HTTP-상태코드)
- [HTTP 헤더1](#HTTP-헤더1)

###### Reference
- **(main)** 인프런 김영한 HTTP 강좌 : https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/dashboard


## IP 프로토콜 그리고 TCP/UDP
클라이언트와 서버는 인터넷을 통해 데이터를 전달한다. 이 때 출발지와 목적지를 정의하는 방법은 기기마다 고유의 IP 주소를 갖는 것이다. 이 때 데이터를 **패킷**이라는 단위로 묶어 보낸다. 하지만 데이터는 전송되는 과정에서 다양한 계층을 거치고 여러 기기들을 거치게 된다. (특히, 거리가 멀수록) 따라서 이 때, 패킷이 목적지에 잘 전달될 수 있도록 거치는 지점마다 목적지를 잘 설정할 필요가 있다. 이를 위해 **TCP와 UDP**가 등장하였다.  
### TCP/UDP
![image](https://user-images.githubusercontent.com/70999462/225890592-ecbbb1cd-ac2a-451f-9210-b6b5a9b4b17b.png)
> [인프런 김영한 HTTP 강좌](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/dashboard)

**TCP(Transmission Control Protocol)** 는 어플리케이션 계층으로부터 전달된 데이터에 TCP 정보를 생성하여 감싼다. 여기엔 출발지 PORT, 목적지 PORT, 전송 제어, 순서, 검증 정보 등등이 담겨있다. TCP의 주요 특징 중 하나는 출발지와 목적지 간 논리적 연결을 확인하는 것이다. 이를 **3 way handshake** 라고 한다. 또한 TCP는 데이터가 전송되었을 때 제대로 수신되었음을 알려주는 일종의 회신 기능이 있다. 그리고 여러 패킷이 순서대로 잘 전달될 수 있도록 하는 순서 보장 기능이 있다. (만약 세 번째 패킷이 두 번째 패킷보다 먼저 도착하면, 두 번째 패킷부터 다시 보내도록 한다.)  
**UDP(User Datagram Protocol)** 은 TCP와 같은 계층에 있으나, 앞서 말한 기능들이 들어있지 않은 백지에 가까운 상태이다. PORT 및 체크섬 정도의 기능만 있을 뿐 데이터의 전달 순서를 보장하지 않는다. 하지만 그만큼 단순하게 구현되어 있으며 속도가 빠르다. 이미 현실 인터넷 프로토콜에서는 TCP가 90퍼에 가까운 점유율을 보유하고 있으나, 사용자가 어플리케이션을 통해 UDP에 최적화된 기능들을 구현할 수 있다.
## PORT
PORT는 하나의 IP 주소, 즉 하나의 기기 안에서 동작하는 여러 프로세스를 구분하기 위한 위치정보이다. 컴퓨터는 여러 어플리케이션을 사용할 수 있기 때문에, 여러 서버로부터 데이터를 받게 된다. 따라서 데이터들을 구분하기 위한 정보가 필요하고, 이를 PORT라고 한다. IP가 아파트라면, PORT는 아파트 내에 있는 호수 번호라고 할 수 있다. TCP/IP 패킷에는 출발지,목적지의 IP 뿐만 아니라 PORT 번호까지 담고 있기 때문에 알맞은 PORT로 데이터를 전달할 수 있다.
  - 0 ~ 65535 : 할당 가능
    - 0 ~ 1023 : 잘 알려진 포트, 이 범위에 있는 PORT는 사용하지 않는 것을 권장
    - FTP : 20,21
    - TELNET : 23
    - HTTP : 80
    - HTTPS : 443

## DNS
![image](https://user-images.githubusercontent.com/70999462/225898186-914c7b04-3e9d-4fe4-89ed-278a0fb35e2b.png)
> [인프런 김영한 HTTP 강좌](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/dashboard)

**DNS(Domain Name System)** 는 일련의 숫자로 구성되어 외우기 어려운 IP 주소를 대신해 알기 쉬운 직관적인 이름을 부여하는 방법이다. 사용자가 접속하고자 하는 서버의 IP 주소를 모르더라도 DNS를 통해 연결할 수 있다. 또한 서버의 IP 주소가 변경되면 변경된 주소를 도메인과 연결시키면, 사용자는 IP 주소의 변경과 상관없이 동일하게 접속이 가능하다.

## URL과 URI
URI는 URL을 포함하는 개념이다. R은 Resource의 약자, I는 Identifier의 약자이다. 따라서 리소스를 식별하는 역할을 한다. URL의 L은 Locator의 약자로 말 리소스의 위치 정보를 갖고 있다. 보통 URI와 URL을 같은 의미로 부르는 경우가 많으며, 굳이 나누자면 URI가 더 큰 개념이다.
- URI(URL)에는 기본적으로 http or https(http + secure) 등의 프로토콜 + 호스트명(or IP 주소) + 포트 번호(생략) + 패스(/search) + 쿼리 파라미터(스트링) 으로 구성되어 있다.
  - ex) https://www.google.com/search?q=uri

# HTTP
우리가 사용하는 모든 웹 기반 어플리케이션은 HTTP를 사용하고 있다. 사진, 텍스트, 음성파일, JSON 등등 모든 형태의 데이터를 전송이 가능하다. 뿐만 아니라 서버 간 통신을 할 때도 HTTP를 사용하여 통신한다. 따라서 웹 개발자에게 HTTP에 대한 지식과 이해는 기본이다. HTTP는 시대를 거듭할수록 버전이 진화하였는데 가장 많이 사용되며 HTTP의 기반이 되는 버전은 **1.1**이다.
- TCP : HTTP/1.1, HTTP/2
- UDP : HTTP/3
- HTTP/1.1을 주로 사용하며 2와 3도 사용빈도도 증가하고 있다. HTTP/3의 경우 UDP 프로토콜을 사용하기 때문에 어플리케이션에 따라 성능을 개선할 수 있는 장점이 있다. 따라서 3버전의 경우도 증가하는 추세이다.

![image](https://user-images.githubusercontent.com/70999462/227689542-8b0fadf0-6051-46f1-8e7d-6b7c78ba4809.png)
> 구글의 경우 검색기능에 있어서 h3 (HTTP/3) 즉, UDP 방식을 사용하고 있으며, 속도가 매우 빠르다. (크롬 - 개발자 도구(F12))

![image](https://user-images.githubusercontent.com/70999462/227689608-eb401153-8e0d-4ecf-963c-df8ac0056474.png)
> 네이버의 경우 h2와 h1.1 (HTTP/2 & HTTP/1.1) 즉, TCP 방식을 사용하고 있다.

## Stateless
Stateless란 상태를 저장하지 않는다는 뜻이다. 클라이언트와 서버는 요청과 응답으로 통신을 하는데, 이 때 **클라이언트에서 요청한 정보를 서버 측에서 저장하는 것을 Stateful, 저장하지 않는 것을 Stateless라고 한다.**  
### 만약 클라이언트 X의 정보를 서버 Y1이 다 저장하고 있다면, X는 Y1에 요청할 정보가 줄어들 것이다. 그만큼 Y1이 X에 대해 알고있는 정보들이 많기 때문이다. 하지만 만약 그 정보를 알고 있는 Y1에 장애가 발생하여 다른 서버 Y2로 대체되었다면? X는 다시 처음부터 정보를 보내야할 것이다. 대체된 서버 Y2는 X에 대한 정보가 없기 때문이다.  
클라이언트의 상태를 저장하지 않는 Stateless 방식을 사용한다면 서버의 확장성(스케일 아웃)이 높아지기 때문에 많은 요청이 오는 경우 그만큼 서버를 투입시킬 수 있다.(확장성 용이) 하지만 클라이언트는 매번 서버에게 보내는 요청 데이터의 양이 증가한다. 따라서 서버는 Stateful(브라우저 쿠키, 서버 세션 등)과 Stateless를 적절하게 섞어야 한다. Stateless를 기반으로 설계하되 필요할 경우 Stateful(상태유지)를 최소한으로 사용하는 방식을 사용한다.
> 김영한 강사님의 말씀 : 서버 개발자에게 있어서는 Stateless 방식을 잘 사용하는 것이 중요하다고 하셨다. 특정 이벤트, 수강신청 등 순식간에 요청이 발생하는 대용량 트래픽 환경에서 Stateless 환경을 잘 구성하는게 중요! 따라서 처음에는 그냥 정적 페이지를 띄워서 사용자 요청의 텀을 주는 방식을 사용한다고 한다.

## 비 연결성
HTTP는 기본적으로 비연걸성 특징을 가지고 있다. 비 연걸성이란 클라이언트와 서버가 요청과 응답 이후에는 서로 연결되지 않는 것이다. 요청과 응답 이후에도 서로가 연결되어 있다면 서버는 클라이언트와 계속해서 연결되어 있기 위해 자원을 사용할 것이다. 하지만 연결하지 않으면 통신에 필요한 자원만 사용할 수 있다.  
### 특정 서비스의 접속자 수가 100명이 있다고, 서버에서 받는 데이터 요청 개수가 100개인 것은 아니다. 실제로는 그것보다 훨씬 작다. 사용자는 해당 서비스를 사용하면서 중간중간 요청을 보내기 때문이다. 따라서 서버는 요청이 들어왔을 때만 잠시 연결하고, 응답한 후에는 연결을 해제하여 사용 자원을 최소화한다.
하지만 클라이언트와 서버의 통신 간에 데이터의 요청 및 응답이 1회로 끝나지 않는 경우가 많다. 특히, HTML, CSS, JS 등 복합적인 데이터를 받아 렌더링 하는 경우가 다반사이다. HTTP의 비연결성은 연결과 해제를 반복함으로써 (TCP의 3 handshake 빈도 증가) 속도가 더 느려질 수 있다. 이를 보완하기 위해 **지속 연결(Persistent Connections) 방식을 사용한다.** 지속연결이란 필요한 데이터를 다 받을 때까지 연결상태를 유지하는 것이다.

## HTTP 메시지 구조
HTTP의 요청과 응답 메시지는 4개의 영역으로 나뉘어 있다. **시작라인, 헤더, 공백 라인, 메시지 바디**로 구성된다.
![image](https://user-images.githubusercontent.com/70999462/227696427-4acdfb47-7316-4af6-b327-ba7011848e2a.png)
> [인프런 김영한 HTTP 강좌](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/dashboard)

- 시작 라인(Start Line)
  - 요청 : HTTP 메서드(서버가 수행해야 할 동작을 지정) 및 요청 대상(절대 경로 사용) 그리고 HTTP 버전을 담고 있다.
  - 응답 : HTTP 버전, 상태 코드(200,300,400 등) 그리고 상태코드에 대한 설명(OK 등)이 담겨 있다.
- 헤더(HTTP Header)
  - 요청 : "Host: 도메인 이름" (ex. Host: www.google.com)
  - 응답 : HTTP 전송에 필요한 부가 정보들을 모두 담고 있다. 따라서 보내는 데이터의 크기 및 내용, 압축, 인증 등등 여러 메타 데이터가 담겨 있다.
    - 지정되어 있는 표준 헤더의 종류가 많으며, 사용자가 직접 작성할 수도 있다. (이는 서로 약속된 클라이언트 - 서버끼리만 동작)
- 메시지 바디
  - 실제 전송할 데이터들이 담기는 곳이다. HTML 문서, 이미지, 영상, JSON 등 바이트 단위로 표현될 수 있는 모든 데이터들이 전송 가능하다.

## HTTP API 설계
HTTP API를 설계할 때 있어서 기본은 계층적 구조로 설계해야 한다는 것이다. URI를 보고 이게 어떤 리소스를 대상으로 하는 것인지 알 수 있어야 한다.  
`예를 들어 회원 조회, 추가, 삭제 등의 URI 설계를 해야 한다면 해당 URI 마다 다루는 리소스가 무엇인지 구별해야 한다. 여기서 리소스는 회원이다. URI에는 추가하고 삭제하는 등의 행위에 대한 내용이 들어가 있으면 안된다.`
> /create-member (x) , /members/{id} (o) : 철저하게 리소스에 대한 정보만 가지고 있음.  
> 계층 구조상, 회원이라는 리소스를 관리하는 상위 컬렉션이기 때문에 복수단어 사용을 권장한다. (member (x), members(o))

# HTTP 메서드
## GET 메서드
- 리소스를 조회하는 메서드이다. 데이터를 전달할 일이 있을 경우, **쿼리 파라미터, 쿼리 스트링**을 주로 사용한다.
  - GET 메서드도 메세지 바디에 데이터를 담아 전달할 수 있지만, 지원하지 않는 경우가 있어서 권장하지 않는다.
## POST 메서드
- POST 메서드는 클라이언트가 서버에게 데이터를 전달하여 이를 기반으로 데이터를 처리해달라고 요청하는 메서드이다.
- **메시지 바디**를 통해 서버로 요청 데이터를 전달한다. 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행한다.
- 전달된 데이터를 바탕으로 새로운 리소스를 등록하거나, 프로세스를 변경, 처리하는 데 사용된다.
  - 신규 데이터를 등록하는 경우, 클라이언트가 메시지 바디에 데이터를 담아 전달하면, 서버는 해당 데이터를 통해 새로운 리소스를 등록하고 응답 데이터에 새롭게 생성된 식별자를 전달한다.  
  ex) POST: /memebers -> /members/100 **반환**
- POST는 데이터를 추가하는 작업 이외에 프로세스의 변경(주문에서 배달로 변경), 프로세스 처리(전달한 데이터를 기반으로 주문, 결제) 등에도 사용된다.
  - 따라서 리소스 URI에 POST 요청이 들어오면 리소스 마다 어떠한 처리가 이루어지는지 따로 설정해야 한다.(POST가 다루는 범위가 넓기 떄문)
- POST의 결과로 새로운 리소스가 생성되지 않을 수도 있다. POST를 통해 프로세스를 변경시키는 경우가 있는데 이 때, URI의 구조는 동사가 사용될 수가 있다. 이러한 URI를 **컨트롤 URI**라고 한다.
- 또한 GET처럼 조회용 메서드로 사용될 수도 있다. GET은 메시지 바디에 데이터를 담는 것을 지원하지 않는 경우가 있는데, 메시지 바디를 사용해(JSON 사용) 조회 데이터를 넘겨야 하는 경우에는 GET이 아닌 POST를 사용한다.
## PUT 메서드
- PUT은 리소스가 없는 경우, 새로 데이터를 생성(POST 역할)하며, 기존 데이터가 있는 경우 전달받은 데이터로 다시 대체한다. (이 때, 전달 받은 데이터로만 완전히 값을 대체해버린다. 아래 그림 참조) 따라서 부분 변경이 불가능하다. (값을 완전히 대체하기 때문)
![image](https://user-images.githubusercontent.com/70999462/235356831-10c5d089-fc6f-4047-998f-6f3fb08d01d7.JPG)
![image](https://user-images.githubusercontent.com/70999462/235356854-f7234af1-2eab-45f8-9b8b-a5ea70c32941.JPG)
> [인프런 김영한 HTTP 강좌](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/dashboard)
- POST와 다른 점은, POST는 리소스의 자세한 정보 즉, 식별자를 모르지만 PUT의 경우 해당 리소스가 어떤 ID 값을 갖는지 알고 있는 상태에서 값의 변경을 요청한다는 것이다.  
ex) POST : /members,  PUT : /members/100
## PATCH 메서드
- PUT은 부분 변경을 할 수 없기 때문에, 부분 수정이 가능하게 한 메서드가 PATCH 메서드이다.
- 해당 리소스의 변경하고 싶은 부분만 필드로 지정하여 값을 전달하면, 서버는 전달받은 필드에 해당하는 부분만 데이터를 변경한다.
- PUT과 마찬가지로 리소스의 정확한 식별자를 알고 있는 상태에서 요청한다.
## DELETE 메서드
- 말 그대로 리소스를 제거하는 메서드이다. 제거하는 메서드이기 때문에 리소스의 정확한 식별자 값을 전달한다.

## HTTP 메서드의 속성
![image](https://github.com/whxogus215/Backend-Study-Archive/assets/70999462/718d860a-4545-4c9c-bcb0-f86a8041a394)
> [출처](https://ko.wikipedia.org/wiki/HTTP)

1. 안전(Safe)
- 메서드를 호출했을 때 리소스가 변하지 않으면 안전한다. ex) GET은 조회이기 때문에 리소스가 변경되지 않는다. POST는 생성,수정,삭제가 가능하기 때문에 호출할 때마다 리소스가 변경된다.
2. 멱등(Idempotent)
- 메서드를 1번 호출하든 100번 호출하든 결과가 변하지 않는다.
  - PUT 메서드의 경우, 같은 리소스에 대한 요청을 할 경우 계속 값을 덮어쓰기 때문에 결과가 동일하다.
  - DELETE 메서드의 경우, 같은 리소스에 대한 요청을 할 경우 계속 값을 삭제하기 때문에 호출할 때마다 삭제한 결과가 동일하게 나타난다.
  - **POST 메서드의 경우, 리소스를 추가로 생성하거나 상태를 변경시킬 수 있기 때문에 호출할 때마다 다른 결과가 나온다. 따라서 POST는 멱등하지 않다.**
- 멱등성을 판단하는 경우 : 자동 복구 메커니즘, 클라이언트가 자동으로 요청을 다시 해야할 경우, 해도 되는지를 판단 -> POST의 경우 두 번 호출되면 문제가 발생할 수 있다.
3. 캐시 가능(Cacheable)
- 응답 결과 리소스를 캐시에 저장해서 사용할 수 있는지에 대한 판단 여부이다.
  - GET, HEAD, POST, PATCH가 가능하지만 실제로는 GET, HEAD(바디 제거)만 사용한다.
    - 데이터가 큰 이미지 파일의 경우, 캐시에 저장한다면 재호출되었을 때 빠르게 응답이 가능하다.

# HTTP 메서드 활용
- 클라이언트에서 서버로 데이터를 전달하는 방식은 크게 두 가지로 나뉘어진다.
  - 쿼리 파라미터를 사용한다.
    - GET 방식에서 (조회용)데이터를 전달해야하는 경우 - 정렬, 키워드 등
  - 메시지 바디에 데이터를 담아 전송한다.
    - POST, PATCH, PUT 방식에서 사용된다.
    - 회원 가입, 상품 주문, 리소스 등록, 리소스 변경 등
## 정적 데이터 조회
- 특정 이미지 등 단순한 정적인 리소스를 조회하는 경우, GET 메서드를 사용한다.
- 이미지, 정적 텍스트 문서 등에 사용되며, 쿼리 파라미터는 사용하지 않아도 된다.
## 동적 데이터 조회
- 특정한 키워드, 정렬 조건을 선택하여 리소스를 조회하는 경우, 서버는 전달받은 조건에 따라 값을 찾게 된다. 따라서 동적 데이터 조회라고 할 수 있다. 클라이언트는 쿼리 파라미터를 통해 서버 측에 데이터를 전달한다.
  - `https://www.google.com/search?q=hello&hl=ko`
  - **주로 검색, 게시판 목록의 정렬 필터**에 사용된다.
  - 조회이기 때문에 GET을 사용한다. (쿼리 파라미터 사용)
## HTML Form 데이터 전송
- **HTML Form은 GET과 POST만을 지원한다.**
- POST 전송의 경우, 클라이언트는 메시지 바디를 사용하여 데이터를 전송할 수 있다. 이 때 웹 브라우저는 입력받은 데이터 값을 key=value 형식으로 데이터를 만들어서 전달한다.
  - HTML Form의 경우 Content-Type은 application/x-www-form-urlencoded 이다.
    - urlencoded인 이유는 한글이 입력했을 때 이를 인코딩하여 처리하기 때문이다.
- GET 조회의 경우, 쿼리 파라미터를 통해 전달되기 때문에 메시지 바디에 내용이 존재하지 않는다.
- 값 이외에 파일 등 여러 데이터를 같이 전송해야 하는 경우 마찬가지로 POST를 사용한다.
  - 이 때, Content-Type은 multipart/form-data 이다.
    - 이는 바이너리 데이터(파일 업로드)를 처리하기 위해 사용되는 경우이다.
    - multipart이므로 여러 파일 종류를 보낼 수 있다.
## HTTP API 데이터 전송
- API의 경우, 주로 JSON을 사용하며 Content-Type은 application/json 이다.
- 서버와 서버 간 통신, 앱 클라이언트와 서버 간 통신, HTML이 아닌 자바스크립트 기반(AJAX - React, Vue) 웹 클라이언트와 통신 등에 사용되는 데이터 전송 방식이다.
- HTML Form과는 다르게 GET,POST 이외에도 PUT,PATCH를 사용할 수 있다.
  - GET은 마찬가지로 쿼리 파라미터를 사용하며, 조회용으로 사용된다.

## HTTP API 설계 예시
- 리소스를 생성할 때, POST를 사용할 것인지 PUT을 사용할 것인지에 따라 달라질 수 있다.
- POST를 사용할 경우, 클라이언트는 등록되는 리소스의 URI를 알 수 없다. /memebers - POST 이런식으로 요청을 하면 서버 측에서 /members/100 과 같이 리소스 URI를 새로 생성한다.
  - 이처럼 리소스를 서버가 관리하는 디렉토리를 **컬렉션(Collection)**이라고 한다. 위 예시에서 컬렉션은 /memebers 이다.
- PUT을 사용할 경우, 클라이언트는 등록되는 리소스의 URI를 알고 있다.(클라이언트가 지정하는 방식)
  - 클라이언트는 /files/{filename} - PUT 이런식으로 URI를 알고 있다. 즉, 클라이언트가 지정한다.
  - 이처럼 클라이언트가 리소스를 관리하는 디렉토리를 **스토어(Store)**라고 한다. 위 예시에서 스토어는 /files 이다.
- HTML Form을 사용하는 경우, 쓸 수 있는 메서드가 GET, POST로 제한된다. 따라서 서버 측에서 수행해야 하는 로직이 복잡해질 때, HTTP API 또한 복잡해질 수 밖에 없다.
  - HTTP API 설계 원칙에서 동사는 사용하지 않는 것으로 하였다. 하지만 GET과 POST 만을 사용한다면 어쩔 수 없이 동사를 통해 리소스를 구분해야 한다. -> 컨트롤 URI
    - 회원 목록 /members - GET
    - 회원 등록 폼 /members/new - GET
    - 회원 등록 /members/new - POST
    - 회원 조회 /members/{id}
    - 회원 수정 폼 /members/{id}/edit - GET
    - 회원 수정 /members/{id}/edit - POST
    - 회원 삭제 /members/{id}/delete - POST
  - 이처럼 DELETE,PUT을 사용한다면 간편해질 URI가 동사를 사용함으로써 복잡해질 수 있다. 하지만 실무에서는 이처럼 컨트롤 URI를 사용해서 구분하는 경우가 많다.
- ![image](https://github.com/whxogus215/Backend-Study-Archive/assets/70999462/7040f55f-16a0-4192-9935-bf7c848b5e81)
> [인프런 김영한 HTTP 강좌](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/dashboard)

# HTTP 상태코드
- 클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 방법이다. 상태 코드를 통해 요청의 결과를 보고한다.
  - 1XX (Informational) 는 거의 사용하지 않는다.
1. 2XX (Successful) : 요청이 정상적으로 처리된다.
2. 3XX (Redirection) : 요청을 완료하려면 추가 행동이 필요하다.
3. 4XX (Client Error) : 클라이언트 측의 오류(잘못된 문법 등)
4. 5XX (Server Error) : 서버 오류
> 만약 클라이언트가 모르는 상태 코드가 전달됐을 경우, 코드의 상위 상태코드(백의 자리 수)를 보고 판단한다. ex) 299 -> 2XX (Successful)

## 2XX (성공)
1. 200 OK : 요청이 성공.
2. 201 Created : **POST 요청**을 통해 리소스 생성을 할 경우, 정상적으로 생성되었음을 알림
  - 응답 시, Location 헤더 필드를 통해 생성된 URI의 정보를 반환할 수 있다. (ex. /members/100)
3. 202 Accepted : 요청이 접수되었으나 처리가 완료되지는 않았다. (자주 사용하지 않음)
4. 204 No Content : 서버가 요청을 성공적으로 수행했지만, 응답에 보낼 데이터가 없다.
 - 클라이언트가 응답 메세지를 통해 작업을 처리할 필요가 없는 경우 (ex. 웹 문서 편집기의 저장 버튼 : 저장을 한 뒤에 따로 메세지 없이 같은 화면을 유지하기 때문)
 - 단순히 204(2XX) 코드만으로 성공을 인식할 수 있다.

## 3XX (Redirection)
- 요청을 완료하기 위해 유저 에이전트(클라이언트의 프로그램 ex. 웹 브라우저)의 추가 조치가 필요하다.
### 리다이렉션(Redirection)이란
- 서버 측에서 응답을 할 때, 3XX 응답 결과와 헤더에 Location 정보를 보낸다면, 웹 브라우저는 그 Location으로 자동으로 이동한다.
- ![리다이렉션1](https://github.com/whxogus215/Backend-Study-Archive/assets/70999462/4aaa4a67-0ee2-4941-abc4-30e0ee11c5aa)
> [인프런 김영한 HTTP 강좌](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/dashboard)
  - 사용자가 따로 입력하지 않아도 웹 브라우저가 자동으로 새 URI로 요청을 한다.
1. 영구 리다이렉션 : 특정 리소스의 URI가 영구적으로, 즉 완전히 변경되었을 경우이다.
  - /members -> /users , /event -> /new-event
  - 검색 엔진이 URL을 변경한다. 상태코드는 301(Moved Permanently)을 많이 사용하며, 308(Permanent Redirect)도 비슷하다.
  - 301의 경우, 리다이렉트시 요청 본문 데이터가 없어지고, **요청 메서드가 GET으로 변한다.** 따라서 POST 요청을 보냈을 때 301 코드가 온다면, 변경된 URI로 GET 요청을 하게 된다. (ex. POST 요청으로 데이터를 작성했을 시, 새로운 URI로 GET 요청을 하여 아예 새로운 페이지를 조회하게 된다.)
  - 308의 경우, 301과는 다르게 본문에 대한 데이터(body)와 요청 메서드가 동일하게 유지된다. 하지만 실무에서는 301을 주로 사용한다고 한다. (HTTP의 스펙의도와는 다르게 웹 브라우저가 GET으로 요청하도록 구현되어 있기 때문) 따라서 요청 메서드와 본문 데이터가 유지되어야 할 경우 308을 사용한다. 

2. 일시 리다이렉션(실무에서 제일 많이 사용) : 리소스가 영구적으로 변하지 않고, 일시적으로 변경되었을 경우를 말한다.
  - 검색엔진에서 URL을 변경하면 안된다.
  - 302의 경우, 301처럼 GET으로 변하고, 본문이 제거될 수 있다.
  - 307의 경우, 308처럼 요청 메서드와 본문 데이터가 변경되지 않는다.
  - 303의 경우, 302와 기능은 같으나 요청 메서드가 무조건 GET으로 변경된다. (302의 경우 요청 메서드가 변경이 안될 수도 있기 때문)

3. PRG(Post/Redirect/Get)
- POST로 특정 URI로 요청을 보낸 상태에서 새로고침을 한다면 웹 브라우저는 동일한 POST 요청을 하게 된다. 이는 중복주문이 될 수 있다는 뜻이다.
- PRG 패턴을 사용하면 서버 측에서 오류를 처리하는 빈도수가 현저히 줄어든다. (매우 중요)
- ![PRG 사용전](https://github.com/whxogus215/Backend-Study-Archive/assets/70999462/9810356b-49a0-4e77-88b8-2b490df79daa)
> [인프런 김영한 HTTP 강좌](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/dashboard)
- POST 주문 후에 주문 결과 화면을 GET 메서드로 리다이렉트하게 한다.(302 상태코드와 함께 결과화면에 해당하는 URI를 Location 헤더에 담아서 전송) 그러면 사용자는 새로고침을 하더라도 기존의 POST에서 GET으로 바뀐 상태이기 때문에 결과 화면만을 계속 보게 보게된다. (중복 주문이 안됨)
- ![PRG 사용후](https://github.com/whxogus215/Backend-Study-Archive/assets/70999462/3486c7d9-9b42-4d8c-81ac-80fa7f9a0f0e)
> [인프런 김영한 HTTP 강좌](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/dashboard)

4. 304 Not Modified
- 클라이언트가 로컬 PC의 캐시에 있는 리소스를 사용할 수 있다는 응답 코드이다. 즉, 클라이언트가 캐시로 리다이렉트한다.
  - 클라이언트가 리소스를 캐시에서 가져올 수 있다면, 네트워크의 용량은 많이 줄어들 것이다.
- 304 응답은 클라이언트가 로컬에 있는 캐시를 사용해야 하기 때문에 응답 메시지의 body가 있으면 안된다.

## 4XX (Client Error)
- **클라이언트의 요청에 잘못된 문법 등으로** 서버가 요청을 수행할 수 없는 상태이다.
- 오류의 원인이 클라이언트에 있다.
  - 4XX와 5XX를 구분하는 가장 중요한 특징은 4XX의 경우 클라이언트 측에서 잘못된 거기 때문에 똑같은 시도를 반복해도 계속해서 요청이 실패한다.
  - 하지만 5XX의 경우, 서버가 정상적으로 복구가 된다면 같은 요청을 시도했을 때 성공할 가능성이 있다. (서버가 그대로여도 계속 반복했을 때 성공할 확률이 존재한다.)

1. 400 Bad Request
 - **클라이언트가 잘못된 요청**을 해서 서버가 요청을 처리할 수 없다.
 - 주로 요청 구문, 메세지 등에 오류가 발생했을 경우로, 클라이언트는 다시 요청 내용을 검토하고 보내야 한다.
   - ex) 요청 파라미터가 잘못되거나, API 스펙이 맞지 않을 때(문자열 전송인데 숫자를 전송할 경우 등)
 - 따라서 백엔드 개발자는 유효성 검사를 통해 정확한 상태 코드를 전달하도록 설계해야 된다.
2. 401 Unauthorized
 - 클라이언트가 해당 리소스에 대한 인증이 필요하다. (로그인이 되지 않은 것)
 - 말 그대로 Authentication(인증)이 되지 않은 것이다.
   - Authentication(인증) : 본인이 누구인지 확인하는 것 (로그인)
   - Authorization(인가) : 권한을 부여하는 것 (특정 리소스에 접근할 수 있는 권한), 인증 -> 인가
 - 메세지는 Unauthorized 이지만 실제로는 인증되지 않음을 의미(Unauthentication)
3. 403 Forbidden
 - 서버가 요청을 이해했지만 승인을 거부한 경우이다.
 - 사용자가 로그인을 정상적으로 하여 인증 되었지만, 접근 권한이 불충분한 경우이다.
   - 부여받은 권한 이상의 리소스를 접근하려하는 경우에 받는 응답상태이다.
 - 말 그대로 Forbidden, 해당 리소스에 대해 금지된 상태이다.
4. 404 Not Found
  - 요청 리소스를 찾을 수 없음
  - 4XX인 이유는, 서버 입장에서는 찾을 수 없는 리소스이기 때문에 클라이언트 측에서 잘못 요청한 것이기 때문이다.
  - 또는 사용자가 특정 권한 이상의 리소스에 접근하려고 할 때 403 대신 404를 보낼 수도 있다.
    - 단순히 금지됐다고 하면, 해당 리소스가 존재한다는 것을 나타내는 것이기 때문에 완전히 리소스를 숨기고 싶을 때 서버에 리소스가 없는 척하면서 응답할 수 있는 방법이다.

## 5XX (Server Error)
- 서버 문제로 오류가 발생하기 때문에 재시도 했을 때 성공할 수도 있다.(복구 등)
1. 500 Internal Server Error
- 서버 문제로 오류가 발생했을 때 보내는 코드로, 백엔드 설계시 애매하다 싶으면 500으로 보낸다.
2. 503 Service Unavailable
- 서비스 이용 불가, 서버의 일시적인 과부하 혹은 예정된 작업으로 요청을 잠시동안 처리할 수 없는 상태이다.
- Retry-After 헤더 필드를 통해 얼마 뒤에 복구되는지 보낼 수도 있다.
- 주로 500번이 많이 사용된다.
- 500번대는 정말 서버에 에러가 생겼을 경우에만 보내야 한다. 인증되지 않은 리소스 요청에 대한 응답 같은 경우엔 정상적인 프로세스로 500번대 응답코드는 적절하지 않다.(4XX나 2XX로 해결)

# HTTP 헤더1

## 표현
HTTP를 통해 서버에서 응답을 할 때, 표현(Representation)이라는 말을 사용한다. 실제 DB에 저장되어 있는 데이터나 기타 바이트 코드를
클라이언트에게 전달할 때는 HTML, JSON, XML 등의 형식으로 바꾸어서 전달한다. 이처럼 특정 데이터를 특정 폼으로 바꾸어 전송하기 때문에 표현이라는 말을 쓴다.
즉, 표현(표현 데이터)이란 실제 HTTP를 통해 전송되는 데이터를 뜻한다. 
### 표현 데이터의 메타데이터를 담는 헤더 정보
1. Content-Type : 표현 데이터의 형식
   - HTTP 바디에 해당하는 부분이 어떠한 형식으로 되어있는지에 대한 정보를 담고 있다. (ex. text/html; charset=utf-8 , application/json, image/png)
2. Content-Encoding : 표현 데이터의 압축 방식
   - 데이터를 보내는 입장에서 데이터를 압축하였다면 데이터를 받는 입장에서는 압축을 해제하기 위해 어떠한 방식으로 압축되었는지 알아야 한다. 인코딩 헤더의 정보를 확인한 뒤 압축을 해제한다.
   - ex. gzip, deflate, identity(압축을 안한다는 뜻)
3. Content-Language : 표현 데이터의 자연 언어(ex. 한국어(ko), 영어(en) 등)
4. Content-Length : 표현 데이터의 길이

## 협상
클라이언트가 서버 측으로부터 데이터를 요청할 때, 요청헤더 필드에 `Accept`에 해당하는 부분이다.
이는 클라이언트가 서버 측으로부터 받고 싶은, 선호하는 표현을 요청하는 부분이다. 이 협상헤더는 요청 시에만 사용한다.
1. Accept : 클라이언트가 선호하는 미디어 타입 전달
2. Accept-Charset : 클라이언트가 선호하는 문자 인코딩
3. Accept-Encoding : 클라이언트가 선호하는 압축 인코딩
4. Accept-Language : 클라이언트가 선호하는 자연 언어
![적용 전](https://github.com/whxogus215/Backend-Study-Archive/assets/70999462/bbb908fa-a594-405d-ba57-6b3710a9c8f7)
![적용 후](https://github.com/whxogus215/Backend-Study-Archive/assets/70999462/915e94c5-13be-4a1c-8a85-0e952cba31f9)
> [인프런 김영한 HTTP 강좌](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/dashboard)
### 협상과 우선순위(Quality Values(q))
클라이언트는 요청 시에 Accept에 해당하는 항목에 우선순위를 줄 수 있다. 우선순위는 **0에서 1사이이며, 값이 클수록 높은 우선순위이다.**
만약 우선순위 값이 없다면 생략된 것으로 1이다.  
- ex) Accept-Language : ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7
  - ko-KR;**q=1(생략)**
  - ko;**q=0.9**
  - en-US;**q=0.8**
  - en;**q=0.7**

또한 우선순위는 구체적인 것에 대해 우선순위를 부여한다. 만약, Accept에 text/*, text/plain, text/plain;format=flowed, */*이 있을 경우,
우선순위는 다음과 같다. 
1. text/plain;format=flowed
2. text/plain
3. text/*
4. \*/\*

마찬가지로 구체적인 것을 기준으로 미디어 타입의 우선순위를 맞춘다.
![협상3](https://github.com/whxogus215/Backend-Study-Archive/assets/70999462/0ae1e800-3d8d-4ad9-a10e-315dd1ab74aa)
> [인프런 김영한 HTTP 강좌](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/dashboard)

## 전송방식
### 단순전송
Content-Length의 길이가 정해져 있으며, 데이터를 한번에 다 보낸다.
[단순 전송 그림]
### 압축전송
말 그대로 데이터를 한 번 압축해서 전송하며, 전송 용량이 줄어든다. 이 때 응답 헤더에는 당연히 `Content-Encoding` 필드가 있어야 한다. 그래야 받는 사람이 적절하게 디코딩을 할 수 있기 때문이다.
[압축 전송 그림]
### 분할전송
응답 헤더에 `Transfer-Encoding : chunked`라는 항목이 있으며, 덩어리 형식으로 데이터를 보내는 것이다. 보내는 데이터에 몇 바이트 씩 나뉘어 지는지에 대한 정보도 메시지 바디에 표시되어 있다.
[분할 전송 그림]
### 범위전송
클라이언트는 해당 데이터의 바이트 범위를 지정해서 요청할 수 있다. 이 때, 응답 헤더에서는 `Range`라는 필드가 존재한다. 그러면 서버는 요청한 범위에 해당하는 만큼만 데이터를 보낸다.
[범위 전송 그림]

## 일반정보
HTTP의 요청헤더 혹은 응답헤더에 존재하는 항목 중 사용자 혹은 서버에 관련된 정보들을 담는 필드에 대한 부분이다.
### Referer
굉장히 많이 쓰이며, 내용 자체는 단순하다. 현재 요청된 페이지의 이전 웹 페이지 주소를 담고 있다. 예를 들어
구글에서 검색한 뒤, 어떤 특정 사이트에 들어가게 되면 HTTP 요청헤더의 Referer 필드에 특정사이트에 들어가기 전인 구글 주소가 들어있다.
이 Referer를 사용하면 유입 경로를 분석할 수 있다. **따라서 Referer는 요청헤더에 사용된다.**
### User-Agent
클라이언트의 애플리케이션 혹은 웹 브라우저에 관한 정보를 담고 있다. 서버 측에서 User-Agent 정보를 알고 있다면 서비스에 대한 통계를 낼 수 있으며,
어떤 종류의 브라우저에서 장애가 발생하는지를 User-Agent 정보를 통해 파악할 수 있다. **따라서 User-Agent도
요청헤더에 사용된다.**
### Server
요청을 처리하는 Origin 서버의 소프트웨어 정보를 말한다. HTTP 요청은 클라이언트에서 바로 서버로 가지 않고,
중간에 캐시/프록시 서버를 거칠 수 있다. 따라서 클라이언트의 요청을 최종적으로 처리하고 응답하는 서버를 Origin 서버라고 한다.
ex) Server : Apache/2.2.22 (Debian), nginx  
**Server는 당연히 응답헤더에 사용된다.**
### Date
말 그대로 메시지가 발생한 날짜와 시간 정보를 담고 있다. 기준은 응답에 관한 시간이기 때문에 **Date는 
응답헤더에 사용된다.**

## 특별한 정보
### Host
매우 중요한 정보이다. **요청헤더에서 사용되며 필수이다.** 하나의 서버는 여러 도메인(웹 사이트)를 처리할 수가 있다. 따라서
요청 측에서 어떤 도메인으로 값을 받으려는건지를 알아야 한다. 즉, Host는 클라이언트 측에서 정보를 요청하는 대상 사이트이다.
[Host 사진]
### Location
웹 브라우저가 3XX 응답 결과일 경우 Location 필드를 통해 자동 이동할 URI 정보를 보낼 수 있다. (서버 측에서)
201 (Created)의 경우에도 Location 필드를 설정할 수 있는데, 이는 요청에 의해 **생성된 리소스 URI** 정보이다.
### Retry-After
유저 에이전트(웹 브라우저)가 다음 요청을 하기까지 기다려야 하는 시간에 대한 정보를 담고 있다.
만약 503 서버 오류일 경우, 서비스가 언제까지 이용이 불가능한지에 대해 알려줄 수 있다.  
ex) Retry-After : Fri, 31 Dec 2000, Retry-After : 120 (초단위) - 120초에 한 번씩 요청 가능하다는 뜻
### Authorization
클라이언트 인증 정보를 서버 측에 전달하는 항목이다. 이 때, 인증하는 방식에 따라 내용이 달라질 수 있다.
### WWW-Authenticate
클라이언트가 리소스에 접근 시 필요한 인증방법을 정의하는 항목이다. 만약 401 (Unauthorized) 에러가 났을 경우,
서버는 응답과 함께 리소스에 접근하기 위해 필요한 인증에 대한 자세한 내용을 전달할 수 있다.  
ex) WWW-Authenticate: Newauth realm="apps", type=1, title="Login to \"apps\"", Basic realm="simple"
    
## 쿠키







  




