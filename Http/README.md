# Contents Of Http
- [IP 프로토콜 그리고 TCP/UDP](#IP-프로토콜-그리고-TCP/UDP)
- [PORT 그리고 DNS](#PORT)
- [URL 과 URI](#url과-uri)
- [HTTP 특징](#http)
  - [Stateless](#stateless)
  - [비 연결성](#비-연걸성)
  - [HTTP 메시지 구조](#http-메시지-구조)
- [HTTP API 설계](#http-api-설계)
- [HTTP 메서드](#HTTP)
  - [HTTP 속성](#HTTP-메서드의-속성)
  - 

###### Reference
- **(main)** 인프런 김영한 HTTP 강좌 : https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/dashboard


## IP 프로토콜 그리고 TCP/UDP
클라이언트와 서버는 인터넷을 통해 데이터를 전달한다. 이 때 출발지와 목적지를 정의하는 방법은 기기마다 고유의 IP 주소를 갖는 것이다. 이 때 데이터를 **패킷**이라는 단위로 묶어 보낸다. 하지만 데이터는 전송되는 과정에서 다양한 계층을 거치고 여러 기기들을 거치게 된다. (특히, 거리가 멀수록) 따라서 이 때, 패킷이 목적지에 잘 전달될 수 있도록 거치는 지점마다 목적지를 잘 설정할 필요가 있다. 이를 위해 **TCP와 UDP**가 등장하였다.  
### TCP/UDP
![image](https://user-images.githubusercontent.com/70999462/225890592-ecbbb1cd-ac2a-451f-9210-b6b5a9b4b17b.png)
> [인프런 김영한 HTTP 강좌](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/dashboard)

**TCP(Transmission Control Protocol)** 는 어플리케이션 계층으로부터 전달된 데이터에 TCP 정보를 생성하여 감싼다. 여기엔 출발지 PORT, 목적지 PORT, 전송 제어, 순서, 검증 정보 등등이 담겨있다. TCP의 주요 특징 중 하나는 출발지와 목적지 간 논리적 연결을 확인하는 것이다. 이를 **3 way handshake** 라고 한다. 또한 TCP는 데이터가 전송되었을 때 제대로 수신되었음을 알려주는 일종의 회신 기능이 있다. 그리고 여러 패킷이 순서대로 잘 전달될 수 있도록 하는 순서 보장 기능이 있다. (만약 세 번째 패킷이 두 번째 패킷보다 먼저 도착하면, 두 번째 패킷부터 다시 보내도록 한다.)  
**UDP(User Datagram Protocol)** 은 TCP와 같은 계층에 있으나, 앞서 말한 기능들이 들어있지 않은 백지에 가까운 상태이다. PORT 및 체크섬 정도의 기능만 있을 뿐 데이터의 전달 순서를 보장하지 않는다. 하지만 그만큼 단순하게 구현되어 있으며 속도가 빠르다. 이미 현실 인터넷 프로토콜에서는 TCP가 90퍼에 가까운 점유율을 보유하고 있으나, 사용자가 어플리케이션을 통해 UDP에 최적화된 기능들을 구현할 수 있다.
## PORT
PORT는 하나의 IP 주소, 즉 하나의 기기 안에서 동작하는 여러 프로세스를 구분하기 위한 위치정보이다. 컴퓨터는 여러 어플리케이션을 사용할 수 있기 때문에, 여러 서버로부터 데이터를 받게 된다. 따라서 데이터들을 구분하기 위한 정보가 필요하고, 이를 PORT라고 한다. IP가 아파트라면, PORT는 아파트 내에 있는 호수 번호라고 할 수 있다. TCP/IP 패킷에는 출발지,목적지의 IP 뿐만 아니라 PORT 번호까지 담고 있기 때문에 알맞은 PORT로 데이터를 전달할 수 있다.
  - 0 ~ 65535 : 할당 가능
    - 0 ~ 1023 : 잘 알려진 포트, 이 범위에 있는 PORT는 사용하지 않는 것을 권장
    - FTP : 20,21
    - TELNET : 23
    - HTTP : 80
    - HTTPS : 443

## DNS
![image](https://user-images.githubusercontent.com/70999462/225898186-914c7b04-3e9d-4fe4-89ed-278a0fb35e2b.png)
> [인프런 김영한 HTTP 강좌](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/dashboard)

**DNS(Domain Name System)** 는 일련의 숫자로 구성되어 외우기 어려운 IP 주소를 대신해 알기 쉬운 직관적인 이름을 부여하는 방법이다. 사용자가 접속하고자 하는 서버의 IP 주소를 모르더라도 DNS를 통해 연결할 수 있다. 또한 서버의 IP 주소가 변경되면 변경된 주소를 도메인과 연결시키면, 사용자는 IP 주소의 변경과 상관없이 동일하게 접속이 가능하다.

## URL과 URI
URI는 URL을 포함하는 개념이다. R은 Resource의 약자, I는 Identifier의 약자이다. 따라서 리소스를 식별하는 역할을 한다. URL의 L은 Locator의 약자로 말 리소스의 위치 정보를 갖고 있다. 보통 URI와 URL을 같은 의미로 부르는 경우가 많으며, 굳이 나누자면 URI가 더 큰 개념이다.
- URI(URL)에는 기본적으로 http or https(http + secure) 등의 프로토콜 + 호스트명(or IP 주소) + 포트 번호(생략) + 패스(/search) + 쿼리 파라미터(스트링) 으로 구성되어 있다.
  - ex) https://www.google.com/search?q=uri

# HTTP
우리가 사용하는 모든 웹 기반 어플리케이션은 HTTP를 사용하고 있다. 사진, 텍스트, 음성파일, JSON 등등 모든 형태의 데이터를 전송이 가능하다. 뿐만 아니라 서버 간 통신을 할 때도 HTTP를 사용하여 통신한다. 따라서 웹 개발자에게 HTTP에 대한 지식과 이해는 기본이다. HTTP는 시대를 거듭할수록 버전이 진화하였는데 가장 많이 사용되며 HTTP의 기반이 되는 버전은 **1.1**이다.
- TCP : HTTP/1.1, HTTP/2
- UDP : HTTP/3
- HTTP/1.1을 주로 사용하며 2와 3도 사용빈도도 증가하고 있다. HTTP/3의 경우 UDP 프로토콜을 사용하기 때문에 어플리케이션에 따라 성능을 개선할 수 있는 장점이 있다. 따라서 3버전의 경우도 증가하는 추세이다.

![image](https://user-images.githubusercontent.com/70999462/227689542-8b0fadf0-6051-46f1-8e7d-6b7c78ba4809.png)
> 구글의 경우 검색기능에 있어서 h3 (HTTP/3) 즉, UDP 방식을 사용하고 있으며, 속도가 매우 빠르다. (크롬 - 개발자 도구(F12))

![image](https://user-images.githubusercontent.com/70999462/227689608-eb401153-8e0d-4ecf-963c-df8ac0056474.png)
> 네이버의 경우 h2와 h1.1 (HTTP/2 & HTTP/1.1) 즉, TCP 방식을 사용하고 있다.

## Stateless
Stateless란 상태를 저장하지 않는다는 뜻이다. 클라이언트와 서버는 요청과 응답으로 통신을 하는데, 이 때 **클라이언트에서 요청한 정보를 서버 측에서 저장하는 것을 Stateful, 저장하지 않는 것을 Stateless라고 한다.**  
### 만약 클라이언트 X의 정보를 서버 Y1이 다 저장하고 있다면, X는 Y1에 요청할 정보가 줄어들 것이다. 그만큼 Y1이 X에 대해 알고있는 정보들이 많기 때문이다. 하지만 만약 그 정보를 알고 있는 Y1에 장애가 발생하여 다른 서버 Y2로 대체되었다면? X는 다시 처음부터 정보를 보내야할 것이다. 대체된 서버 Y2는 X에 대한 정보가 없기 때문이다.  
클라이언트의 상태를 저장하지 않는 Stateless 방식을 사용한다면 서버의 확장성(스케일 아웃)이 높아지기 때문에 많은 요청이 오는 경우 그만큼 서버를 투입시킬 수 있다.(확장성 용이) 하지만 클라이언트는 매번 서버에게 보내는 요청 데이터의 양이 증가한다. 따라서 서버는 Stateful(브라우저 쿠키, 서버 세션 등)과 Stateless를 적절하게 섞어야 한다. Stateless를 기반으로 설계하되 필요할 경우 Stateful(상태유지)를 최소한으로 사용하는 방식을 사용한다.
> 김영한 강사님의 말씀 : 서버 개발자에게 있어서는 Stateless 방식을 잘 사용하는 것이 중요하다고 하셨다. 특정 이벤트, 수강신청 등 순식간에 요청이 발생하는 대용량 트래픽 환경에서 Stateless 환경을 잘 구성하는게 중요! 따라서 처음에는 그냥 정적 페이지를 띄워서 사용자 요청의 텀을 주는 방식을 사용한다고 한다.

## 비 연결성
HTTP는 기본적으로 비연걸성 특징을 가지고 있다. 비 연걸성이란 클라이언트와 서버가 요청과 응답 이후에는 서로 연결되지 않는 것이다. 요청과 응답 이후에도 서로가 연결되어 있다면 서버는 클라이언트와 계속해서 연결되어 있기 위해 자원을 사용할 것이다. 하지만 연결하지 않으면 통신에 필요한 자원만 사용할 수 있다.  
### 특정 서비스의 접속자 수가 100명이 있다고, 서버에서 받는 데이터 요청 개수가 100개인 것은 아니다. 실제로는 그것보다 훨씬 작다. 사용자는 해당 서비스를 사용하면서 중간중간 요청을 보내기 때문이다. 따라서 서버는 요청이 들어왔을 때만 잠시 연결하고, 응답한 후에는 연결을 해제하여 사용 자원을 최소화한다.
하지만 클라이언트와 서버의 통신 간에 데이터의 요청 및 응답이 1회로 끝나지 않는 경우가 많다. 특히, HTML, CSS, JS 등 복합적인 데이터를 받아 렌더링 하는 경우가 다반사이다. HTTP의 비연결성은 연결과 해제를 반복함으로써 (TCP의 3 handshake 빈도 증가) 속도가 더 느려질 수 있다. 이를 보완하기 위해 **지속 연결(Persistent Connections) 방식을 사용한다.** 지속연결이란 필요한 데이터를 다 받을 때까지 연결상태를 유지하는 것이다.

## HTTP 메시지 구조
HTTP의 요청과 응답 메시지는 4개의 영역으로 나뉘어 있다. **시작라인, 헤더, 공백 라인, 메시지 바디**로 구성된다.
![image](https://user-images.githubusercontent.com/70999462/227696427-4acdfb47-7316-4af6-b327-ba7011848e2a.png)
> [인프런 김영한 HTTP 강좌](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/dashboard)

- 시작 라인(Start Line)
  - 요청 : HTTP 메서드(서버가 수행해야 할 동작을 지정) 및 요청 대상(절대 경로 사용) 그리고 HTTP 버전을 담고 있다.
  - 응답 : HTTP 버전, 상태 코드(200,300,400 등) 그리고 상태코드에 대한 설명(OK 등)이 담겨 있다.
- 헤더(HTTP Header)
  - 요청 : "Host: 도메인 이름" (ex. Host: www.google.com)
  - 응답 : HTTP 전송에 필요한 부가 정보들을 모두 담고 있다. 따라서 보내는 데이터의 크기 및 내용, 압축, 인증 등등 여러 메타 데이터가 담겨 있다.
    - 지정되어 있는 표준 헤더의 종류가 많으며, 사용자가 직접 작성할 수도 있다. (이는 서로 약속된 클라이언트 - 서버끼리만 동작)
- 메시지 바디
  - 실제 전송할 데이터들이 담기는 곳이다. HTML 문서, 이미지, 영상, JSON 등 바이트 단위로 표현될 수 있는 모든 데이터들이 전송 가능하다.

## HTTP API 설계
HTTP API를 설계할 때 있어서 기본은 계층적 구조로 설계해야 한다는 것이다. URI를 보고 이게 어떤 리소스를 대상으로 하는 것인지 알 수 있어야 한다.  
`예를 들어 회원 조회, 추가, 삭제 등의 URI 설계를 해야 한다면 해당 URI 마다 다루는 리소스가 무엇인지 구별해야 한다. 여기서 리소스는 회원이다. URI에는 추가하고 삭제하는 등의 행위에 대한 내용이 들어가 있으면 안된다.`
> /create-member (x) , /members/{id} (o) : 철저하게 리소스에 대한 정보만 가지고 있음.  
> 계층 구조상, 회원이라는 리소스를 관리하는 상위 컬렉션이기 때문에 복수단어 사용을 권장한다. (member (x), members(o))

# HTTP 메서드
## GET 메서드
- 리소스를 조회하는 메서드이다. 데이터를 전달할 일이 있을 경우, **쿼리 파라미터, 쿼리 스트링**을 주로 사용한다.
  - GET 메서드도 메세지 바디에 데이터를 담아 전달할 수 있지만, 지원하지 않는 경우가 있어서 권장하지 않는다.
## POST 메서드
- POST 메서드는 클라이언트가 서버에게 데이터를 전달하여 이를 기반으로 데이터를 처리해달라고 요청하는 메서드이다.
- **메시지 바디**를 통해 서버로 요청 데이터를 전달한다. 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행한다.
- 전달된 데이터를 바탕으로 새로운 리소스를 등록하거나, 프로세스를 변경, 처리하는 데 사용된다.
  - 신규 데이터를 등록하는 경우, 클라이언트가 메시지 바디에 데이터를 담아 전달하면, 서버는 해당 데이터를 통해 새로운 리소스를 등록하고 응답 데이터에 새롭게 생성된 식별자를 전달한다.  
  ex) POST: /memebers -> /members/100 **반환**
- POST는 데이터를 추가하는 작업 이외에 프로세스의 변경(주문에서 배달로 변경), 프로세스 처리(전달한 데이터를 기반으로 주문, 결제) 등에도 사용된다.
  - 따라서 리소스 URI에 POST 요청이 들어오면 리소스 마다 어떠한 처리가 이루어지는지 따로 설정해야 한다.(POST가 다루는 범위가 넓기 떄문)
- POST의 결과로 새로운 리소스가 생성되지 않을 수도 있다. POST를 통해 프로세스를 변경시키는 경우가 있는데 이 때, URI의 구조는 동사가 사용될 수가 있다. 이러한 URI를 **컨트롤 URI**라고 한다.
- 또한 GET처럼 조회용 메서드로 사용될 수도 있다. GET은 메시지 바디에 데이터를 담는 것을 지원하지 않는 경우가 있는데, 메시지 바디를 사용해(JSON 사용) 조회 데이터를 넘겨야 하는 경우에는 GET이 아닌 POST를 사용한다.
## PUT 메서드
- PUT은 리소스가 없는 경우, 새로 데이터를 생성(POST 역할)하며, 기존 데이터가 있는 경우 전달받은 데이터로 다시 대체한다. (이 때, 전달 받은 데이터로만 완전히 값을 대체해버린다. 아래 그림 참조) 따라서 부분 변경이 불가능하다. (값을 완전히 대체하기 때문)
![image](https://user-images.githubusercontent.com/70999462/235356831-10c5d089-fc6f-4047-998f-6f3fb08d01d7.JPG)
![image](https://user-images.githubusercontent.com/70999462/235356854-f7234af1-2eab-45f8-9b8b-a5ea70c32941.JPG)
> [인프런 김영한 HTTP 강좌](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/dashboard)
- POST와 다른 점은, POST는 리소스의 자세한 정보 즉, 식별자를 모르지만 PUT의 경우 해당 리소스가 어떤 ID 값을 갖는지 알고 있는 상태에서 값의 변경을 요청한다는 것이다.  
ex) POST : /members,  PUT : /members/100
## PATCH 메서드
- PUT은 부분 변경을 할 수 없기 때문에, 부분 수정이 가능하게 한 메서드가 PATCH 메서드이다.
- 해당 리소스의 변경하고 싶은 부분만 필드로 지정하여 값을 전달하면, 서버는 전달받은 필드에 해당하는 부분만 데이터를 변경한다.
- PUT과 마찬가지로 리소스의 정확한 식별자를 알고 있는 상태에서 요청한다.
## DELETE 메서드
- 말 그대로 리소스를 제거하는 메서드이다. 제거하는 메서드이기 때문에 리소스의 정확한 식별자 값을 전달한다.

## HTTP 메서드의 속성
![image](HTTP 속성표)
> [출처](https://ko.wikipedia.org/wiki/HTTP)

1. 안전(Safe)
- 메서드를 호출했을 때 리소스가 변하지 않으면 안전한다. ex) GET은 조회이기 때문에 리소스가 변경되지 않는다. POST는 생성,수정,삭제가 가능하기 때문에 호출할 때마다 리소스가 변경된다.
2. 멱등(Idempotent)
- 메서드를 1번 호출하든 100번 호출하든 결과가 변하지 않는다.
  - PUT 메서드의 경우, 같은 리소스에 대한 요청을 할 경우 계속 값을 덮어쓰기 때문에 결과가 동일하다.
  - DELETE 메서드의 경우, 같은 리소스에 대한 요청을 할 경우 계속 값을 삭제하기 때문에 호출할 때마다 삭제한 결과가 동일하게 나타난다.
  - **POST 메서드의 경우, 리소스를 추가로 생성하거나 상태를 변경시킬 수 있기 때문에 호출할 때마다 다른 결과가 나온다. 따라서 POST는 멱등하지 않다.**
- 멱등성을 판단하는 경우 : 자동 복구 메커니즘, 클라이언트가 자동으로 요청을 다시 해야할 경우, 해도 되는지를 판단 -> POST의 경우 두 번 호출되면 문제가 발생할 수 있다.
3. 캐시 가능(Cacheable)
- 응답 결과 리소스를 캐시에 저장해서 사용할 수 있는지에 대한 판단 여부이다.
  - GET, HEAD, POST, PATCH가 가능하지만 실제로는 GET, HEAD(바디 제거)만 사용한다.
    - 데이터가 큰 이미지 파일의 경우, 캐시에 저장한다면 재호출되었을 때 빠르게 응답이 가능하다.

# HTTP 메서드 활용
- 클라이언트에서 서버로 데이터를 전달하는 방식은 크게 두 가지로 나뉘어진다.
  - 쿼리 파라미터를 사용한다.
    - GET 방식에서 (조회용)데이터를 전달해야하는 경우 - 정렬, 키워드 등
  - 메시지 바디에 데이터를 담아 전송한다.
    - POST, PATCH, PUT 방식에서 사용된다.
    - 회원 가입, 상품 주문, 리소스 등록, 리소스 변경 등
## 정적 데이터 조회
- 특정 이미지 등 단순한 정적인 리소스를 조회하는 경우, GET 메서드를 사용한다.
- 이미지, 정적 텍스트 문서 등에 사용되며, 쿼리 파라미터는 사용하지 않아도 된다.
## 동적 데이터 조회
- 특정한 키워드, 정렬 조건을 선택하여 리소스를 조회하는 경우, 서버는 전달받은 조건에 따라 값을 찾게 된다. 따라서 동적 데이터 조회라고 할 수 있다. 클라이언트는 쿼리 파라미터를 통해 서버 측에 데이터를 전달한다.
  - `https://www.google.com/search?q=hello&hl=ko`
  - **주로 검색, 게시판 목록의 정렬 필터**에 사용된다.
  - 조회이기 때문에 GET을 사용한다. (쿼리 파라미터 사용)
## HTML Form 데이터 전송
- **HTML Form은 GET과 POST만을 지원한다.**
- POST 전송의 경우, 클라이언트는 메시지 바디를 사용하여 데이터를 전송할 수 있다. 이 때 웹 브라우저는 입력받은 데이터 값을 key=value 형식으로 데이터를 만들어서 전달한다.
  - HTML Form의 경우 Content-Type은 application/x-www-form-urlencoded 이다.
    - urlencoded인 이유는 한글이 입력했을 때 이를 인코딩하여 처리하기 때문이다.
- GET 조회의 경우, 쿼리 파라미터를 통해 전달되기 때문에 메시지 바디에 내용이 존재하지 않는다.
- 값 이외에 파일 등 여러 데이터를 같이 전송해야 하는 경우 마찬가지로 POST를 사용한다.
  - 이 때, Content-Type은 multipart/form-data 이다.
    - 이는 바이너리 데이터(파일 업로드)를 처리하기 위해 사용되는 경우이다.
    - multipart이므로 여러 파일 종류를 보낼 수 있다.
## HTTP API 데이터 전송
- API의 경우, 주로 JSON을 사용하며 Content-Type은 application/json 이다.
- 서버와 서버 간 통신, 앱 클라이언트와 서버 간 통신, HTML이 아닌 자바스크립트 기반(AJAX - React, Vue) 웹 클라이언트와 통신 등에 사용되는 데이터 전송 방식이다.
- HTML Form과는 다르게 GET,POST 이외에도 PUT,PATCH를 사용할 수 있다.
  - GET은 마찬가지로 쿼리 파라미터를 사용하며, 조회용으로 사용된다.

## HTTP API 설계 예시
- 리소스를 생성할 때, POST를 사용할 것인지 PUT을 사용할 것인지에 따라 달라질 수 있다.
- POST를 사용할 경우, 클라이언트는 등록되는 리소스의 URI를 알 수 없다. /memebers - POST 이런식으로 요청을 하면 서버 측에서 /members/100 과 같이 리소스 URI를 새로 생성한다.
  - 이처럼 리소스를 서버가 관리하는 디렉토리를 **컬렉션(Collection)**이라고 한다. 위 예시에서 컬렉션은 /memebers 이다.
- PUT을 사용할 경우, 클라이언트는 등록되는 리소스의 URI를 알고 있다.(클라이언트가 지정하는 방식)
  - 클라이언트는 /files/{filename} - PUT 이런식으로 URI를 알고 있다. 즉, 클라이언트가 지정한다.
  - 이처럼 클라이언트가 리소스를 관리하는 디렉토리를 **스토어(Store)**라고 한다. 위 예시에서 스토어는 /files 이다.
- HTML Form을 사용하는 경우, 쓸 수 있는 메서드가 GET, POST로 제한된다. 따라서 서버 측에서 수행해야 하는 로직이 복잡해질 때, HTTP API 또한 복잡해질 수 밖에 없다.
  - HTTP API 설계 원칙에서 동사는 사용하지 않는 것으로 하였다. 하지만 GET과 POST 만을 사용한다면 어쩔 수 없이 동사를 통해 리소스를 구분해야 한다. -> 컨트롤 URI
    - 회원 목록 /members - GET
    - 회원 등록 폼 /members/new - GET
    - 회원 등록 /members/new - POST
    - 회원 조회 /members/{id}
    - 회원 수정 폼 /members/{id}/edit - GET
    - 회원 수정 /members/{id}/edit - POST
    - 회원 삭제 /members/{id}/delete - POST
  - 이처럼 DELETE,PUT을 사용한다면 간편해질 URI가 동사를 사용함으로써 복잡해질 수 있다. 하지만 실무에서는 이처럼 컨트롤 URI를 사용해서 구분하는 경우가 많다.
- ![image](참고하면 좋은 URI 설계 개념)
> [인프런 김영한 HTTP 강좌](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/dashboard)




  




